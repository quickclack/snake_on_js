{"version":3,"sources":["Board.js","Controls.js","Game.js","Main.js","Score.js","Settings.js","Snake.js","Status.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../app.js","sourcesContent":["'use strict';\r\n\r\nclass Board {\r\n    constructor() {\r\n        this.boardEl = document.getElementById('game');\r\n    }\r\n\r\n    /**\r\n     * Метод получает другие игровые обьекты, которые нужны ему\r\n     * для работы.\r\n     * @param {Settings} settings обьект настроек.\r\n     * @param {Snake} snake обьект змейки.\r\n     */\r\n    init(settings, snake) {\r\n        this.settings = settings;\r\n        this.snake = snake;\r\n    }\r\n\r\n    /**\r\n     * Метод отрисовывает игровое поле.\r\n     */\r\n    renderBoard() {\r\n        for (let row = 0; row < this.settings.rowsCount; row++) {\r\n            let tr = document.createElement('tr');\r\n            this.boardEl.appendChild(tr);\r\n\r\n            for (let col = 0; col < this.settings.colsCount; col++) {\r\n                let td = document.createElement('td');\r\n                tr.appendChild(td);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод отрисовывает змейку на доске.\r\n     */\r\n    renderSnake() {\r\n        const snakeBodyElems = this.getSnakeBodyElems(this.snake.body);\r\n        snakeBodyElems.forEach(function(tdEl) {\r\n            tdEl.classList.add('snakeBody');\r\n        });\r\n    }\r\n\r\n    /** Метод очищает игровое поле от еды. */\r\n    clearFood() {\r\n        document.querySelector('.food').classList.remove('food');\r\n    }\r\n\r\n    /** Метод очищает змейку с игрового поля. */\r\n    clearSnake() {\r\n        const tdElems = document.querySelectorAll('.snakeBody');\r\n        tdElems.forEach(function(td) {\r\n            td.classList.remove('snakeBody');\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Получаем ячейку таблицы.\r\n     * @param {number} x координата по оси x. \r\n     * @param {number} y координата по оси y. \r\n     * @returns {HTMLTableCellElement} тег td \r\n     */\r\n    getCellEl(x, y) {\r\n        return this.boardEl.querySelector(`tr:nth-child(${y}) td:nth-child(${x})`);\r\n    }\r\n\r\n    /**\r\n     * Получаем набор тегов td, представляющих тело змейки.\r\n     * @param {Array} bodyCoords массив обьектов с координатами.\r\n     * @throws {Error} если координаты не будут переданы, то будет выброшена ошибка\r\n     * @returns {HTMLTableCellElement[]}\r\n     */\r\n    getSnakeBodyElems(bodyCoords) {\r\n        if (bodyCoords.length === 0) {\r\n            throw new Error('Не переданы координаты тела змейки.');\r\n        }\r\n\r\n        let bodyElems = [];\r\n        for (let coordinate of bodyCoords) {\r\n            let td = this.getCellEl(coordinate.x, coordinate.y);\r\n            bodyElems.push(td);\r\n        }\r\n        return bodyElems;\r\n    }\r\n\r\n    /**\r\n     * Метод проверяет сьела ли змейка еду.\r\n     * @returns {boolean} true если змейка находится на еде, иначе false.\r\n     */\r\n    didSnakeEatFood() {\r\n        return this.boardEl.querySelector('.food').classList.contains('snakeBody');\r\n    }\r\n\r\n   /**\r\n    * Метод возвращает тег td у которого нет класса snakeBody или food.\r\n    * @returns {HTMLTableCellElement}\r\n    */\r\n   getRandomEmptyTd() {\r\n       const emptyTdElements = document.querySelectorAll('td:not(.snakeBody):not(.food)');\r\n       const randomEmptyTd = emptyTdElements[Math.floor(Math.random() * (emptyTdElements.length - 1))]\r\n       return randomEmptyTd;\r\n\r\n   }\r\n\r\n   /**\r\n    * Метод устанавливает новое случайное положение еды на игровом\r\n    * поле.\r\n    */\r\n   renderNewFood() {\r\n       const emptyTd = this.getRandomEmptyTd();\r\n       emptyTd.classList.add('food');\r\n   }\r\n}","'use strict';\r\n\r\nclass Controls {\r\n    constructor() {\r\n        this.startBtnEl = document.getElementById('startBtn');\r\n        this.pauseBtnEl = document.getElementById('pauseBtn');\r\n    }\r\n\r\n    /**\r\n     * @param {Game} game\r\n     */\r\n    init(game) {\r\n        this.game = game;\r\n    }\r\n\r\n    /**\r\n     * Метод устанавливает обработчики событий на клики по кнопкам\r\n     * \"Старт\" и \"Пауза\", а так же на стрелки перемещения змейки.\r\n     */\r\n    addControlsEventListeners() {\r\n        this.startBtnEl.addEventListener('click', this.game.start.bind(this.game));\r\n        this.pauseBtnEl.addEventListener('click', this.game.pause.bind(this.game));\r\n        document.addEventListener('keydown', this.game.pressKeyHandler.bind(this.game));\r\n    }\r\n}","'use strict';\r\n\r\nclass Game {\r\n    constructor() {\r\n        this.tickIdentifier = null;\r\n        this.messageEl = document.getElementById('message');\r\n    }\r\n\r\n    /**\r\n     * Метод получает другие игровые обьекты, которые нужны ему \r\n     * для работы.\r\n     * @param {Settings} settings \r\n     * @param {Status} status \r\n     * @param {Board} board \r\n     * @param {Snake} snake \r\n     * @param {Menu} menu \r\n     * @param {Score} score\r\n     */\r\n    init(settings, status, board, snake, controls, score) {\r\n        this.settings = settings;\r\n        this.status = status;\r\n        this.board = board;\r\n        this.controls = controls;\r\n        this.snake = snake;\r\n        this.score = score;\r\n    }\r\n\r\n    /**\r\n     * Метод запускает игру.\r\n     */\r\n    start() {\r\n        if (this.status.isPaused()) {\r\n            this.status.setPlaying();\r\n            this.tickIdentifier = setInterval(this.doTick.bind(this), 1000 / this.settings.speed);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод ставит игру на паузу.\r\n     */\r\n    pause() {\r\n        if (this.status.isPlaying()) {\r\n            this.status.setPaused();\r\n            this.stopGame();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Этот метод запускается каждую секунду и осуществляет:\r\n     * 1. перемещение змейки\r\n     * 2. проверяет проиграна/выиграна ли игра\r\n     * 3. увеличивает размер змейки если она ест еду\r\n     * 4. заново отрисовывает положение змейки и еды\r\n     */\r\n    doTick() {\r\n        this.snake.performStep();\r\n        if (this.isSnakeSteppedOntoItself()) {\r\n            this.stopGame();\r\n            this.setMessage('Вы проиграли');\r\n            return;\r\n        }\r\n        if (this.board.didSnakeEatFood()) {\r\n            this.snake.increaseBody();\r\n            this.score.renderCurrentScore(this.snake.body.length);\r\n\r\n            if (this.isGameWon()) {\r\n                this.stopGame();\r\n                this.setMessage('Вы выиграли!');\r\n                return;\r\n            }\r\n\r\n            this.board.clearFood();\r\n            this.board.renderNewFood();\r\n        }\r\n        this.board.clearSnake();\r\n        this.board.renderSnake();\r\n    }\r\n\r\n    /**\r\n     * Метод проверяет выиграна ли игра.\r\n     * @returns {boolean} если длина змейки достигла длины нужной \r\n     * для выиграша, тогда true, иначе false.\r\n     */\r\n    isGameWon() {\r\n        return this.snake.body.length == this.settings.winLength;\r\n    }\r\n\r\n    /**\r\n     * Метод проверяет сьела ли змейка сама себя.\r\n     * @returns {boolean}\r\n     */\r\n    isSnakeSteppedOntoItself() {\r\n        let cellArr = this.snake.body.map(function (cellCoords) {\r\n            return cellCoords.x.toString() + cellCoords.y.toString();\r\n        });\r\n        let head = cellArr.shift();\r\n        return cellArr.includes(head);\r\n    }\r\n\r\n    stopGame() {\r\n        clearInterval(this.tickIdentifier);\r\n    }\r\n\r\n    /**\r\n     * В зависимости от нажатой кнопки (вверх, вниз, влево, вправо) будет\r\n     * вызываться соответствующий метод.\r\n     * @param {KeyboardEvent} event\r\n     */\r\n    pressKeyHandler(event) {\r\n        switch (event.key) {\r\n            case \"ArrowUp\":\r\n                this.snake.changeDirection('up');\r\n                break;\r\n            case \"ArrowDown\":\r\n                this.snake.changeDirection('down');\r\n                break;\r\n            case \"ArrowLeft\":\r\n                this.snake.changeDirection('left');\r\n                break;\r\n            case \"ArrowRight\":\r\n                this.snake.changeDirection('right');\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Метод выводит сообщение на странице.\r\n     * @param {string} text\r\n     */\r\n    setMessage(text) {\r\n        this.messageEl.innerText = text;\r\n    }\r\n}","'use strict';\r\n\r\nwindow.addEventListener('load', () => {\r\n    const settings = new Settings();\r\n    const status = new Status();\r\n    const snake = new Snake();\r\n    const board = new Board();\r\n    const controls = new Controls();\r\n    const game = new Game();\r\n    const score = new Score();\r\n\r\n    const initialSettings = { speed: 5, winLength: 50};\r\n\r\n    settings.init(initialSettings);\r\n    snake.init(settings);\r\n    board.init(settings, snake);\r\n    game.init(settings, status, board, snake, controls, score);\r\n    score.init(settings);\r\n    controls.init(game);\r\n\r\n    board.renderBoard();\r\n    board.renderSnake(snake);\r\n    score.renderPointsForWin(initialSettings.winLength);\r\n    board.renderNewFood();\r\n    score.renderCurrentScore(snake.body.length);\r\n    controls.addControlsEventListeners();\r\n});","'use strict';\r\n\r\nclass Score {\r\n    constructor() {\r\n        this.currentEl = document.querySelector('.current');\r\n        this.toWinEl = document.querySelector('.toWin');\r\n    }\r\n\r\n    /**\r\n     * @param {Settings} settings настройки игры.\r\n     */\r\n    init(settings) {\r\n        this.settings = settings;\r\n    }\r\n\r\n    /**\r\n     * Метод устанавливает текущий счет игрока.\r\n     * @param {string} score\r\n     */\r\n    renderCurrentScore(score) {\r\n        this.currentEl.textContent = score;\r\n    }\r\n\r\n    /**\r\n     * Метод устанавливает количество очков, необходимых\r\n     * для выигрыша.\r\n     * @param {string} points\r\n     */\r\n    renderPointsForWin(points) {\r\n        this.toWinEl.textContent = points;\r\n    }\r\n}","'use strict';\r\n\r\nclass Settings {\r\n    /**\r\n     * @param {Object} params - Параметры игры.\r\n     * @param {Number} params.rowsCount - количество строк игрового поля.\r\n     * @param {Number} params.colsCount - количество колонок игрового поля.\r\n     * @param {Number} params.speed - скорость перемещения змейки.\r\n     * @param {Number} params.winLength - какую длину надо наесть, чтобы выиграть.\r\n     * @throws {Error} если переданы не верные настройки выбрасывается\r\n     * соответствующая ошибка.\r\n     */\r\n    init({rowsCount = 27, colsCount = 29, speed = 5, winLength = 50} = {}) {\r\n        \r\n        if (rowsCount < 10 || rowsCount > 30) {\r\n            throw new Error('Неверные настройки, значение rowsCount должно быть в диапозоне [10, 30]');\r\n        }\r\n        if (colsCount < 10 || colsCount > 30) {\r\n            throw new Error('Неверные настройки, значение colsCount должно быть в диапозоне [10, 30]');\r\n        }\r\n        if (speed < 1 || speed > 10) {\r\n            throw new Error('Неверные настройки, значение speed должно быть в диапозоне [1, 10]');\r\n        }\r\n        if (winLength < 5 || winLength > 50) {\r\n            throw new Error('Неверные настройки, значение winLength должно быть в диапозоне [5, 50]');\r\n        }\r\n\r\n        this.rowsCount = rowsCount;\r\n        this.colsCount = colsCount;\r\n        this.speed = speed;\r\n        this.winLength = winLength;\r\n    }\r\n}","'use strict';\r\n\r\nclass Snake {\r\n    constructor() {\r\n        this.possibleDirections = ['down', 'up', 'left', 'right'];\r\n\r\n        this.body = [{\r\n            x: 1,\r\n            y: 1,\r\n        }];\r\n\r\n        this.direction = 'down';\r\n    }\r\n\r\n    /**\r\n     * @param {Settings} settings настройки игры.\r\n     */\r\n    init(settings) {\r\n        this.settings = settings;\r\n    }\r\n\r\n    /**\r\n     * Меняем направление движения.\r\n     * @param {string} newDirection направление может быть down, up, left, right.\r\n     * @throws {Error} при передаче не корректного направления выбрасывается ошибка.\r\n     */\r\n    changeDirection(newDirection) {\r\n        if (!this.possibleDirections.includes(newDirection)) {\r\n            throw new Error('Передано не верное направление. Вы передали: ' + newDirection);\r\n        }\r\n        if (this.isPassedOppositeDirection(newDirection)) {\r\n            return;\r\n        }\r\n        this.direction = newDirection;\r\n    }\r\n\r\n    /**\r\n     * Метод проверяет, является ли переданое направление, противоположным\r\n     * тому куда сейчас движется змейка.\r\n     * @param {string} newDirection новое направление, может быть up, down, right, left.\r\n     * @returns {boolean} true если новое направление противоположно текущему,\r\n     * инача false.\r\n     */\r\n    isPassedOppositeDirection(newDirection) {\r\n        if (this.direction == 'down' && newDirection == 'up') {\r\n            return true;\r\n        }\r\n        if (this.direction == 'up' && newDirection == 'down') {\r\n            return true;\r\n        }\r\n        if (this.direction == 'left' && newDirection == 'right') {\r\n            return true;\r\n\r\n        }\r\n        if (this.direction == 'right' && newDirection == 'left') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Метод осуществляет шаг змейки. Добавляет ячейку перед существующим\r\n     * положением головы и удаляет одну ячейку в хвосте.\r\n     */\r\n    performStep() {\r\n        let currentHeadCoords = this.body[0];\r\n        let newHeadCoords = {...currentHeadCoords};\r\n        switch (this.direction) {\r\n            case \"down\":\r\n                newHeadCoords.y++;\r\n                break;\r\n            case \"up\":\r\n                newHeadCoords.y--;\r\n                break;\r\n            case \"left\":\r\n                newHeadCoords.x--;\r\n                break;\r\n            case \"right\":\r\n                newHeadCoords.x++;\r\n                break;\r\n        }\r\n\r\n        //если голова уходит за правый край\r\n        if (newHeadCoords.x > this.settings.colsCount) {\r\n            newHeadCoords.x = 1;\r\n        }\r\n        //если голова уходит за нижний край\r\n        if (newHeadCoords.y > this.settings.rowsCount) {\r\n            newHeadCoords.y = 1;\r\n        }\r\n        //если голова уходит за левый край\r\n        if (newHeadCoords.x == 0) {\r\n            newHeadCoords.x = this.settings.colsCount;\r\n        }\r\n        //если голова уходит за верхний край\r\n        if (newHeadCoords.y == 0) {\r\n            newHeadCoords.y = this.settings.rowsCount;\r\n        }\r\n\r\n        this.body.unshift(newHeadCoords);\r\n        this.body.pop();\r\n    }\r\n\r\n    /**\r\n     * Метод дублирует в массиве обьектов представляющих тело змейки\r\n     * последнюю ячейку, т.е. в массиве в конце оказываются два\r\n     * одинаковых обьекта. Когда метод performStep в самом конце\r\n     * удаляет последний элемент массива, он удаляет сдублированный\r\n     * обьект, таким образом тело змейки растет.\r\n     */\r\n    increaseBody() {\r\n        let bodyLastCell = this.body[this.body.length - 1];\r\n        let newBodyLastCell = {...bodyLastCell};\r\n        this.body.push(newBodyLastCell);\r\n    }\r\n\r\n}","'use strict';\r\n\r\n/** Здесь будет храниться статус игры, например мы, завершили или остановлено. */\r\nclass Status {\r\n    constructor() {\r\n        this.condition = 'paused';\r\n    }\r\n\r\n    /** Это означает что мы играем. */\r\n    setPlaying() {\r\n        this.condition = 'playing';\r\n    }\r\n\r\n    /** Это означает что игра на паузе. */\r\n    setPaused() {\r\n        this.condition = 'paused';\r\n    }\r\n\r\n    /**\r\n     * @returns {boolean} если мы сейчас играем, тогда true, иначе false.\r\n     */\r\n    isPlaying() {\r\n        return this.condition === 'playing';\r\n    }\r\n\r\n    /**\r\n     * @returns {boolean} если игра сейчас на паузе, тогда true, иначе false.\r\n     */\r\n    isPaused() {\r\n        return this.condition === 'paused';\r\n    }\r\n}"]}